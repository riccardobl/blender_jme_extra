import bpy


########### AUTOGENERATED WITH PROMPT ###########
# D: i will explain how an human would organize the nodes and then you will write the code for me
# Copilot: Absolutely, I'm here to assist you. Please go ahead and explain how you would like the nodes to be organized. I'll do my best to translate that into code for you.
# D: This is how an human organizes nodes:
# - the material output is always on the right
# - the textures are always on the left
# - the material shader is always in the middle 
# - every other node is placed between its inputs and outputs nodes in a way that makes connections short and intuitive at first sight
# Can you write the code to perform this?
# Copilot: Sure, I understand your requirements now. Here's a Python script that should organize the nodes in the way you described:
# TODO: write a better rearranging algorithm
def rearrangeNodes(node_tree):
    # Define the initial location
    x_location = 0
    y_location = 0

    # Define the spacing between nodes
    x_spacing = 300
    y_spacing = 300

    # Separate output node, material nodes, texture nodes and other nodes
    output_node = next(
        (node for node in node_tree.nodes if node.type == 'OUTPUT_MATERIAL'), None)
    material_nodes = [
        node for node in node_tree.nodes if node.type == 'BSDF_PRINCIPLED']
    texture_nodes = [
        node for node in node_tree.nodes if node.type.startswith('TEX_')]
    other_nodes = [node for node in node_tree.nodes if node not in texture_nodes +
                   material_nodes + [output_node]]

    # Place the output node to the right
    if output_node is not None:
        output_node.location.x = x_spacing * 5
        output_node.location.y = y_spacing

    # Place the material nodes in the center
    for node in material_nodes:
        node.location.x = x_spacing * 2.5
        node.location.y = y_spacing

    # Process texture nodes
    for node in texture_nodes:
        # Set the node location
        node.location.x = x_location
        node.location.y = y_location

        # Update the location for the next node
        y_location -= y_spacing

    # Reset location for other nodes
    x_location = x_spacing
    y_location = 0

    # Process other nodes
    for node in other_nodes:
        # Set the node location
        node.location.x = x_location
        node.location.y = y_location

        # Update the location for the next node
        y_location -= y_spacing

        # If we've reached the end of a column, start a new column
        if y_location < -y_spacing * 5:
            y_location = 0
            x_location += x_spacing
